<h1>Granular convolution with MATLAB</H1>
<h3>Overview of design and implementation</h3>
My overall idea for both the implementation and design is to provide a clear distinction between functions and keep things as simple as possible. To achieve that I try to keep the functions within the GUI program and I use simplistic design with serif script.
<h3>Design</h3>
My GUI design is simplistic, yet intuitive. It uses multiple tabs to clearly distinct the settings used for each of the functions of the program. For clearer separation I use button groups on the playback buttons, file commands and required by the coursework core functionality, to easily distinguish and locate each of the buttons when using the program
An axis is placed above the buttons and tabs to display the spectrogram of the sound that’s currently loaded/convoluted/edited. I’ve added different spectrogram colours that offer different visuals, that often make it easier to distinguish noise/hums.
<ul>The settings tabs include:
<li>Enveloping – a toggle button to turn on enveloping, as well as all of the settings for it with their respective meters from 0 to 100 (attack, sustain, delay, release).</li>
<li>Granular convolution – giving choice between standard and fast Fourier transform, depending on the kind of sound one’s looking for. Noise reduction and choosing the state of the initial load file that would be convoluted as original or modified.</li>
<li>Pitch and speed – providing knobs to turn the speed and pitch up or down, depending on preference with buttons that toggle the transformations. As well as a flip button that can play the track backwards. </li>
  </ul>
The “Load Audio”, “Save Audio” and “Granular Conv” buttons open popups that present the file explorer, allowing the user to choose a file to load or save. Another pop-up is prompted by the “Draw” function that enables the drawing on the spectrogram. The reason for this is that unfortunately, the MAC labs only provided us with the 2018a version of MATLAB, so there was apparently no way to incorporate the drawing in the GUI at least to my knowledge.
<h2>Implementation </h2>
A lot of the implementation regarding the simpler functions has been previously done in the lab sessions with Dr Marshall, so a sizeable chunk of the code regarding them is used for the code in my coursework. Essentially, the Fourier transforms for spectrograms and convolution are code that was originally presented in labs, that has been altered to fit the coursework specifications.
I use separate functions to accomplish most of the tasks, as I was trying not to clutter the buttons with too much redundant code, that would make them difficult to navigate and read. I’ve only left the buttons to perform the conditional operations and alter the parameters passed to each of the other functions, in order to minimize code repetition.
The conditional operations mainly revolve around altering, enabling and disabling different functionality provided in the settings tabs such as choosing between convoluting the original file or the modified one, altering the speed, etc. That allows for a better overview of how the GUI itself works, by just looking at the buttons and how they interact with the settings and checkboxes.
The separation also allows for easier overview of the functionality that’s at the top in the methods section, clearly outlining the different methods and their place in the code with conditional statements. For instance: each button has an enveloping if statement that calls the enveloping function if enveloping is selected as toggled on the settings bar.
Apart from clearer reading of the code, separating the functions away from my conditional statements enabled for easier debugging and better control over the tasks that each function performed. It helped me better understand the code, as well as break it down to smaller chunks, giving more encapsulation and as stated above, providing more control over the individual processes associated with accomplishing a task.
<h3>Algorithms and main requirements</h3>
To accomplish the requirements listed in the coursework brief, I utilize a lot of the lab code as mentioned in the implementation section. Here I’ll go in further detail about the algorithms used and how/if they were altered.
<h3>Pitch and speed</h3>
To perform the actual change of the signal, I used the code provided in week 2, that enabled speed/pitch manipulation. The pitch and speed were originally a scrollable button, until I improved the lab code’s interaction with the GUI through using the following line:
[num, den] = rat(app.PitchKnob.Value);
It allowed me to separate the numerator and denominator of the number that I used in the knob for pitch.
Freehand drawing segments
The drawing segments simply projects the spectrogram in a separate window and enables free hand drawing on the canvas, removing the selected area. It uses Fourier transform to visualize the wave into a spectrogram, then with the part removed, reconfigure it to a modified wave, where the selected frequencies don’t exist.
<h3> Granular convolution </h3>
The granular convolution consists of three main functions: the comparison of the two files and shortening/lengthening the grain file, the extraction of grains and populating an array of them and the Fourier transform of the grains back into signal.
Firstly, MATLAB wouldn’t allow the dot product of two vectors, unless the dimensions matched, to solve this problem, I concluded that to be able to perform the operations I need to match the arrays to the same size. I wrote two simple functions: one of which extends the grain file to the length of the file I want to convolve it with, using repetition of the initial grain file, and another one to shorten the grain file size to the file I want to convolve it with.
The enlarging one checks how roughly many times bigger is the size of the big file, then loops adding the small file to a temporary memory location the given number of times. Since rarely the number of that division is exact, I then concatenate the difference of the two from small and add them to the temporary, finally assigning it to the result. The shrinking one only takes the last bit of the enlarging one, equating the string to the difference of the two.
The second part is the actual extraction of the grains, for which I used the code provided in the labs from week 6, where a random length of the grains is assigned, then extracted in a for loop, then added to a wave.
Then the original sound and the wave are transformed using fast or short time Fourier transform, to then find the dot product of the transformations, resulting in the final product. To add noise cancelling, I use an if statement prior to the dot product of the two vectors, using a median filter to clear the noise from the grains. Then the product is re-transformed into a wave, that’s played at the end of the button sequence.
<h3>Enveloping</h3>
For enveloping, I was on the lookout for online resources, as there wasn’t much to go on in the labs. After struggling for a while, Dr Sidorov kindly gave a link on the MathWorks official website, explaining what I needed to do to get it working. Interestingly, the sum of the individual values for Attack, Sustain, Delay and Release have to all come up to a sum of 100, I could have modified the max of each of the knobs to be at roughly 25 and avoided the issue entirely, but felt like it would defeat the purpose of the function to do so.
<h3>Additional functionalities</h3>
My program implements several additional functionalities, such as changing the color of the spectrograms for both drawing and the display, allowing different visualizations of the same data. To accomplish that, I didn’t necessarily take the most elegant solution, though it is computationally efficient. I set up a long series of if statements that change depending on which radio button for the spectrogram skins is. The skins can prove rather useful if the user has color blindness.
I’ve added a function to save audio files, as I thought that with convolving two files, that would be of interest. It’s merely a few lines of code, that add much needed functionality, that I feel like this program would be incomplete without. Aside from that, noise removal is explained in the algorithms part, by simply applying a filter to the grains, reducing a significant amount of redundant noise. Another additional feature is described above – the ability to choose between modified and original file to convolve, which essentially boils down to an if statement and reloading the file from the path. Another added option is to choose between the fast and short time Fourier transforms.
